#include "riemann_problem.h"
#include <iostream>
#include <fstream>
#include <cmath>

void RiemannProblem::get_prob()
{
    /**
     * Get the problem's full information
     */
    std::cout << "--- Left state info ---\n";
    stateL.get_state();
    std::cout << "--- Right state info ---\n";
    stateR.get_state();
    std::cout << "Gamma: " << gamma << "\n";
}

void RiemannProblem::set_prob(State stateLeft, State stateRight, float gamma_in, float mpa_in)
{
    /**
     * Set problem with left and right states
     */
    stateL = stateLeft;
    stateR = stateRight;
    gamma = gamma_in;
    mpa = mpa_in;
}

/**
 * Setting functions for tests. Still need to specify the
 * gamma and mpa for each test to fully set up the problem.
 *
 * Test 1: Sod test (Toro Section 4.3.3)
 * Test 2: 123 test (Toro Section 4.3.3)
 * Test 3: Strong Shock test (Toro Section 4.3.3)
 * Test 4: Two Shock test (Toro Section 4.3.3)
 */
void RiemannProblem::set_test1(float gamma_in, float mpa_in)
{
    // sod test
    State stateLeft, stateRight;

    float stateL_info[] = {1.0, 0.0, 1.0};
    float stateR_info[] = {0.125, 0.0, 0.1};

    stateLeft.set_state(stateL_info);
    stateRight.set_state(stateR_info);

    gamma = gamma_in;
    mpa = mpa_in;

    stateL = stateLeft;
    stateR = stateRight;
}

void RiemannProblem::set_test2(float gamma_in, float mpa_in)
{
    // 123
    State stateLeft, stateRight;

    float stateL_info[] = {1.0, -2.0, 0.4};
    float stateR_info[] = {1.0, 2.0, 0.4};

    stateLeft.set_state(stateL_info);
    stateRight.set_state(stateR_info);

    gamma = gamma_in;
    mpa = mpa_in;

    stateL = stateLeft;
    stateR = stateRight;
}

void RiemannProblem::set_test3(float gamma_in, float mpa_in)
{
    // strong shock
    State stateLeft, stateRight;

    float stateL_info[] = {1.0, 0.0, 1000.0};
    float stateR_info[] = {1.0, 0.0, 0.01};

    stateLeft.set_state(stateL_info);
    stateRight.set_state(stateR_info);

    gamma = gamma_in;
    mpa = mpa_in;

    stateL = stateLeft;
    stateR = stateRight;
}

void RiemannProblem::set_test4(float gamma_in, float mpa_in)
{
    // two shocks
    State stateLeft, stateRight;

    float stateL_info[] = {5.99924, 19.5975, 460.894};
    float stateR_info[] = {5.99242, -6.19633, 46.0950};

    stateLeft.set_state(stateL_info);
    stateRight.set_state(stateR_info);

    gamma = gamma_in;
    mpa = mpa_in;

    stateL = stateLeft;
    stateR = stateRight;
}

void RiemannProblem::set_gams(float gamm)
{
    /**
     * Set the gamma Gx constants following Toro
     * Section 4.9 conventions
     */
    G1 = (gamm - 1.0) / (2.0 * gamm);
    G2 = (gamm + 1.0) / (2.0 * gamm);
    G3 = 2.0 * gamm / (gamm - 1.0);
    G4 = 2.0 / (gamm - 1.0);
    G5 = 2.0 / (gamm + 1.0);
    G6 = (gamm - 1.0) / (gamm + 1.0);
    G7 = (gamm - 1.0) / 2.0;
    G8 = (gamm - 1.0);
}

void RiemannProblem::set_sounds()
{
    // Compute and sound speeds
    stateL.set_sound(gamma);
    stateR.set_sound(gamma);
}

void RiemannProblem::test_presspos()
{
    // Test pressure positivity for vaccuum
    if (G4 * (stateL.get_sound() + stateR.get_sound()) <= (stateL.get_sound() - stateR.get_sound()))
    {
        std::string vac_message = "Vacuum is generated by data AHHH\n";
        std::cout << vac_message;
        exit;
    }
}

void RiemannProblem::StarPU(float *pP, float *pU)
{
    /**
     * Compute the solution for pressure and velocity
     * in the Star region using the Newton-Raphson method
     * to find roots of Toro equation 4.5 Pressure and
     * velocity are assigned onto the pointers pP and pU
     */
    float POLD, PSTART, UDIFF;
    float FL, FLD, FR, FRD;
    float CHANGE;
    float P, U;

    int i;
    int NRITER = 20;

    float TOLPRE = std::pow(10, -6);

    GuessPM(&PSTART);
    POLD = PSTART;
    UDIFF = stateR.get_velocity() - stateL.get_velocity();

    for (i = 0; i < NRITER; i++)
    {
        prefun(&FL, &FLD, POLD, stateL.get_density(), stateL.get_pressure(), stateL.get_sound());
        prefun(&FR, &FRD, POLD, stateR.get_density(), stateR.get_pressure(), stateR.get_sound());

        P = POLD - (FL + FR + UDIFF) / (FLD + FRD);
        CHANGE = 2.0 * std::abs((P - POLD) / (P + POLD));
        if (CHANGE <= TOLPRE)
        {
            break;
        }
        if (P < 0.0)
        {
            P = TOLPRE;
        }
        POLD = P;
    }
    if (NRITER == i)
    {
        std::cout << "ruh roh, Divergence in Newton-Raphson iteration, gotta die\n";
        exit;
    }
    *pP = P;

    *pU = 0.5 * (stateL.get_velocity() + stateR.get_velocity() + FR - FL);
}

void RiemannProblem::GuessPM(float *pPM)
{
    /**
     * Provide guess value for pressure in the Star Region.
     * Choice is made according to adaptive Riemann solver
     * using PVRS, TRRS, and TSRS approximate Riemann solvers.
     * Further details are discussed in Section 9.5 of Toro.
     */
    float QUSER = 2.0;
    float CUP, PPV, PMIN, PMAX, QMAX;
    float PM;

    float PQ, UM, PTL, PTR;
    float GEL, GER;

    CUP = 0.25 * (stateL.get_density() + stateR.get_density()) * (stateL.get_sound() + stateR.get_sound());
    PPV = 0.5 * (stateL.get_pressure() + stateR.get_pressure()) + 0.5 * (stateL.get_velocity() - stateR.get_velocity()) * CUP;
    PPV = std::max((float)0.0, PPV);
    PMIN = std::min(stateL.get_pressure(), stateR.get_pressure());
    PMAX = std::max(stateL.get_pressure(), stateR.get_pressure());
    QMAX = PMAX / PMIN;

    if ((QMAX <= QUSER) && ((PMIN <= PPV) && (PPV <= PMAX)))
    {
        // select PVRS
        *pPM = PPV;
    }
    else
    {
        if (PPV < PMIN)
        {
            // Two rarefactions
            PQ = std::pow(stateL.get_pressure() / stateR.get_pressure(), gamma);
            UM = ((PQ * (stateL.get_velocity() / stateL.get_sound())) + (stateR.get_velocity() / stateR.get_sound()) + G4 * (PQ - 1.0)) / ((PQ / stateL.get_sound()) + (1.0 / stateR.get_sound()));
            PTL = 1.0 + G7 * (stateL.get_density() - UM) / stateL.get_sound();
            PTR = 1.0 + G7 * (stateR.get_density() - UM) / stateR.get_sound();
            *pPM = (float)0.5 * (stateL.get_pressure() * std::pow(PTL, G3) + stateR.get_pressure() * (std::pow(PTR, G3)));
        }
        else
        {
            // Two shocks
            GEL = sqrt((G5 / stateL.get_density()) / ((G6 * stateL.get_pressure()) + PPV));
            GER = sqrt((G5 / stateR.get_density()) / ((G6 * stateR.get_pressure()) + PPV));
            *pPM = (GEL * stateL.get_density() + GER * stateR.get_density() - (stateR.get_velocity() - stateL.get_velocity())) / (GEL + GER);
        }
    }
}

void RiemannProblem::prefun(float *F, float *FD, float P, float DK, float PK, float CK)
{
    /**
     * Evaluate the pressure functions FL and FR in exact Riemann
     * solver
     */
    float AK, BK, QRT, PRAT;

    if (P < PK)
    {
        // rarefaction wave
        PRAT = P / PK;
        *F = G4 * CK * (std::pow(PRAT, G1) - 1.0);
        *FD = (1.0 / (DK * CK)) * std::pow(PRAT, -G2);
    }
    else
    {
        // shock wave
        AK = G5 / DK;
        BK = G6 * PK;
        QRT = sqrt((AK) / (BK + P));
        *F = (P - PK) * QRT;
        *FD = (1.0 - 0.5 * (P - PK) / (BK + P)) * QRT;
    }
}

void RiemannProblem::sample(float PM, float UM, float S, float *pD, float *pU, float *pP)
{
    /**
     * Sample the solution throughout wave pattern with known
     * Pressure PM and velocity UM. Sampling is performed wrt
     * speed S=X/T. DUP are sampled and set using the float
     * pointers pD, pU, and pP.
     */
    float SHL, SHR, SL, SR, STL, STR;
    float CML, CMR, C, PML, PMR;

    if (S <= UM)
    {
        // Sampling point lies left of contact disc
        if (PM <= stateL.get_pressure())
        {
            // Left rarefaction
            SHL = stateL.get_velocity() - stateL.get_sound();
            if (S <= SHL)
            {
                // Sampled point is left to data state
                *pD = stateL.get_density();
                *pU = stateL.get_velocity();
                *pP = stateL.get_pressure();
            }
            else
            {
                CML = stateL.get_sound() * std::pow(PM / stateL.get_pressure(), G1);
                STL = UM - CML;
                if (S > STL)
                {
                    // Sampled point is Star Left state
                    *pD = stateL.get_density() * std::pow(PM / stateL.get_pressure(), (1.0 / gamma));
                    *pU = UM;
                    *pP = PM;
                }
                else
                {
                    // Sampled point is inside left fan
                    *pU = G5 * (stateL.get_sound() + G7 * stateL.get_velocity() + S);
                    C = G5 * (stateL.get_sound() + G7 * (stateL.get_velocity() - S));
                    *pD = stateL.get_density() * std::pow(C / stateL.get_sound(), G4);
                    *pP = stateL.get_pressure() * std::pow(C / stateL.get_sound(), G3);
                }
            }
        }
        else
        {
            // Left shock
            PML = PM / stateL.get_pressure();
            SL = stateL.get_velocity() - stateL.get_sound() * sqrt(G2 * PML + G1);

            if (S <= SL)
            {
                // Sampled point is left to data state
                *pD = stateL.get_density();
                *pU = stateL.get_velocity();
                *pP = stateL.get_pressure();
            }
            else
            {
                // Sampled point is Star Left state
                *pD = stateL.get_density() * (PML + G6) / (PML * G6 + 1.0);
                *pU = UM;
                *pP = PM;
            }
        }
    }
    else
    {
        // Sampling point lies right of contact disc
        if (PM > stateR.get_pressure())
        {
            // Right shock
            PMR = PM / stateR.get_pressure();
            SR = stateR.get_velocity() + stateR.get_sound() * sqrt(G2 * PMR + G1);
            if (S >= SR)
            {
                // Sampled point is right data state
                *pD = stateR.get_density();
                *pU = stateR.get_velocity();
                *pP = stateR.get_pressure();
            }
            else
            {
                // Sampled point is Star Right state
                *pD = stateR.get_density() * (PMR + G6) / (PMR * G6 + 1.0);
                *pU = UM;
                *pP = PM;
            }
        }
        else
        {
            // Right rarefaction
            SHR = stateR.get_velocity() + stateR.get_sound();

            if (S >= SHR)
            {
                // Sampled point is right data state
                *pD = stateR.get_density();
                *pU = stateR.get_velocity();
                *pP = stateR.get_pressure();
            }
            else
            {
                CMR = stateR.get_sound() * std::pow(PM / stateR.get_pressure(), G1);
                STR = UM + CMR;
                if (S <= STR)
                {
                    // Sampled point is Star Right state
                    *pD = stateR.get_density() * std::pow(PM / stateR.get_pressure(), (1.0 / gamma));
                    *pU = UM;
                    *pP = PM;
                }
                else
                {
                    // Sampled point is inside Left fan
                    *pU = G5 * (-stateR.get_sound() + G7 * stateR.get_velocity() + S);
                    C = G5 * (stateR.get_sound() - G7 * (stateR.get_velocity() - S));
                    *pD = stateR.get_density() * std::pow(C / stateR.get_sound(), G4);
                    *pP = stateR.get_pressure() * std::pow(C / stateR.get_sound(), G3);
                }
            }
        }
    }
}

void RiemannProblem::solve(float DOMLEN, int CELLS, float DIAPH, float TIMEOUT, char *soln_fname)
{
    /**
     * Solve the Riemann Problem given a set domain, number of
     * computing cells, the position of discontinuity, and
     * the time sampled.
     */
    std::ofstream outfile(soln_fname);
    float PM, UM;
    float DX;

    float XPOS, S, DS, US, PS, eS;

    // call some sort of setter validation function

    set_gams(gamma);
    set_sounds();
    test_presspos();

    StarPU(&PM, &UM);

    DX = DOMLEN / float(CELLS);
    outfile << DOMLEN;
    outfile << ", " << CELLS;
    outfile << ", " << DIAPH;
    outfile << ", " << TIMEOUT << ", 0" << std::endl;

    outfile << PM;
    outfile << ", " << UM;
    outfile << ", 0, 0, 0" << std::endl;

    for (int I = 0; I < CELLS; I++)
    {
        XPOS = (float(I) + 0.5) * DX;
        S = (XPOS - DIAPH) / TIMEOUT;

        sample(PM, UM, S, &DS, &US, &PS);
        eS = PS / DS / G8;
        outfile << XPOS;
        outfile << ", " << DS;
        outfile << ", " << US;
        outfile << ", " << PS;
        outfile << ", " << eS / mpa << std::endl;
    }
    outfile.close();
}